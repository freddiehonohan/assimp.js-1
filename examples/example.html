<!doctype html>
<html>
	<div id="container"></div>
    <input type="file" id="file-input" />
    <input type="file" id="file-output" />
    <h3>Contents of the file:</h3>
    <pre id="file-content"></pre>
    <script src="three.min.js"></script>
  	<script src="../assimp.js"></script>
  	<script>

      // http://stackoverflow.com/questions/3582671/how-to-open-a-local-disk-file-with-javascript
      function readSingleFile(e) {
        var file = e.target.files[0];
        if (!file) {
          return;
        }
        var reader = new FileReader();
        reader.onload = function(e) {
          var contents = e.target.result;
          displayContents(contents);
        };
        reader.readAsText(file);
      }

       function writeSingleFile(e) {
        var file = e.target.files[0];
        if (!file) {
          return;
        }
        var writer = new FileWriter();
        writer.onsave = function(e) {
          //var contents = e.target.result;
          //displayContents(contents);
        };
        writer.writerAsText(file);
      }

      //function displayContents(contents) {
      //  var element = document.getElementById('file-content');
      //  element.innerHTML = contents;
      //}

      document.getElementById('file-input').addEventListener('change', readSingleFile, false);
      document.getElementById('file-output').addEventListener('change', writeSingleFile, false);

  		//var ASSIMPAPP = ASSIMPAPP || {}; // Look into namespace func.
  		//var cam = new ASSIMP.aiCamera();
  		var anim = new Module.aiAnimation();
  		var name1 = new Module.aiString("yo1");
  		anim.setName(name1);
  		var name2 = anim.getName();
  		console.log(name2.str());
  		//var data = name2.getData();
      var modelPath = 'duck.dae';//"../assimp/test/models/Collada/duck.dae"
      //var importer = new Module.Importer();
      //var scene = importer.readFile(modelPath, Module.GetTargetRealtimeMaxQualityFlags());
      //console.log(scene)
      // console.log(scene);

      function getPolyTriCount( numVerts ) {
        if( numVerts < 3 ) {
          return 0; 
        }
        return ( numVerts - 2 );
      }

      function getMeshTriCount( mesh ) {
        
        var faceIdx = 0,
            triCount = 0,
            numFaces = mesh.getNumFaces();
     
        for( faceIdx = 0; faceIdx < numFaces; ++faceIdx ) {
          face = mesh.getFace(faceIdx);
          numIndices = face.getNumIndices();
          triCount += getPolyTriCount(numIndices);
        }

        return triCount;
      }


      function triangulatePoly( indices ) {
        // Also, check https://threejsdoc.appspot.com/doc/three.js/src.source/extras/geometries/TextGeometry.js.html
        //assert( orderedPointCount >= 3 );
        var triCount = getPolyTriCount( indices.length ),
            tris = Array( triCount ),
            orderedPointCount = indices.length,
            offsetIndex = 0,
            base0 = 0 + offsetIndex,
            base1 = 1 + offsetIndex,
            lastTri = triCount - 1,
            vtxIdx,
            tri,
            nextTri;

        for( vtxIdx = 0, revVtxIdx = orderedPointCount - 1, triIdx = 0; triIdx < triCount;  ) {
            tri = [base0, base1, base1 + 1];
            tris[triIdx] = [indices[tri[0]], indices[tri[1]], indices[tri[2]]];
            ++triIdx;
            if( triIdx <= lastTri ) {
                nextTri = [tri[2], offsetIndex + revVtxIdx--, tri[0]];
                tris[triIdx] = [indices[nextTri[0]], indices[nextTri[1]], indices[nextTri[2]]];
                base0 = nextTri[1];
                base1 = nextTri[0];
                ++triIdx;
            }
        }// end for

        return tris;
      }

      //function loadVertexAttribute3(mesh, array, bufferAttr, numVertices) {
      //  for ( var vertIdx = 0; vertIdx < numVertices; ++vertIdx ) {
      //    var v = array[vertIdx];
      //    bufferAttr.setXYZ( vertIdx, v.getX(), v.getY(), v.getZ() );
      //  }
      //}

      function loadPositions(mesh, geom) {
        
        var numVertices = mesh.getNumVertices(),
            vertexAttr,
            vertIdx,
            pos;        

        //positions = mesh.getVertices();
        vertexPosAttr = new THREE.BufferAttribute( new Float32Array( numVertices * 3 ), 3 );
        for ( vertIdx = 0; vertIdx < numVertices; ++vertIdx ) {
          pos = mesh.getVertex(vertIdx);//positions[vertIdx];
          vertexPosAttr.setXYZ( vertIdx, pos.getX(), pos.getY(), pos.getZ() );
        }
        geom.addAttribute( 'position', vertexPosAttr );
      }

      function loadIndices(mesh, geom) {

        var i,
            primType,
            numFaces,
            faces,
            triCount,
            face,
            numIndices,
            triCount,
            triIndicesAttr,
            faceTriIdx,
            indices = [],
            tris,
            triCount,
            triIdx,
            tri;

        primType = mesh.getPrimitiveTypes();
        numFaces = mesh.getNumFaces();

        //faces = mesh.getFaces();
        if((primType != Module.aiPrimitiveType.TRIANGLE) || (primType != Module.aiPrimitiveType.POLYGON)) {
          // unsupported type.
        }
        // Compute tri count.
        triCount = getMeshTriCount(mesh);
        triIndicesAttr = new THREE.BufferAttribute( new Uint16Array( triCount * 3 ), 3 ); // check if greater than max uint16
        faceTriIdx = 0;

        for( faceIdx = 0; faceIdx < numFaces; ++faceIdx ) {
          
          face = mesh.getFace(faceIdx);
          numIndices = face.getNumIndices();
          indices.length = numIndices;
          for( i = 0; i < numIndices; ++i ) {
            indices[i] = face.getIndex(i);
          }
          tris = triangulatePoly( indices );
          polyTriCount = tris.length;

          for ( triIdx = 0; triIdx < polyTriCount; ++triIdx ) {
            tri = tris[triIdx];
            triIndicesAttr.setXYZ( faceTriIdx++, tri[0], tri[1], tri[2] );
          }
        }
        
        geom.addAttribute( 'index', triIndicesAttr );
      }

      function loadNormals(mesh, geom) {
        
        var numVertices = mesh.getNumVertices(),
          vertexNrmAttr = new THREE.BufferAttribute( new Float32Array( numVertices * 3 ), 3 ),
          vertIdx,
          nrm;

        for ( vertIdx = 0; vertIdx < numVertices; ++vertIdx ) {
          nrm = mesh.getNormal(vertIdx);//normals[vertIdx];
          vertexNrmAttr.setXYZ( vertIdx, nrm.getX(), nrm.getY(), nrm.getZ() );
        }
        geom.addAttribute( 'normal', vertexNrmAttr );
      }

      function loadVertexColors(mesh, geom, colorSetIdx) {
        
        var numVertices = mesh.getNumVertices(),
        vertexClrAttr = new THREE.BufferAttribute( new Float32Array( numVertices * 3 ), 3 ),
        vertIdx,
        clr;

        for ( vertIdx = 0; vertIdx < numVertices; ++vertIdx ) {
          clr = mesh.getColor(colorSetIdx, vertIdx);
          vertexNrmAttr.setXYZ( vertIdx, clr.getX(), clr.getY(), clr.getZ() );
        }
        geom.addAttribute( 'color', vertexClrAttr );
      }

      function loadTextureCoords(mesh, geom, index) {
        
        var numVertices = mesh.getNumVertices(),
            textureCoordAttr = new THREE.BufferAttribute( new Float32Array( numVertices * 2 ), 2 ),
            vertIdx,
            uv;

        if(index > 1 ){
          // Error. Only 2 sets supported.
          return;
        }

        for ( vertIdx = 0; vertIdx < numVertices; ++vertIdx ) {
          uv = mesh.getTextureCoord(index, vertIdx);
          textureCoordAttr.setXY( vertIdx, uv.getX(), uv.getY() );
        }
        
        if( index === 1 ) {
          geom.addAttribute( 'uv2', textureCoordAttr );
        } else {
          geom.addAttribute( 'uv', textureCoordAttr );
        }
      }

      function loadBones(mesh, geom) {

        //var bones = mesh.getBones(),
        var numBones = mesh.getNumBones(),
            boneIdx,
            bone,
            numWeights,
            weights,
            wtIdx,
            weight,
            mtx;

        for( boneIdx = 0; boneIdx < numBones; ++boneIdx ) {
          bone = mesh.getBone(boneIdx);
          numWeights = bone.getNumWeights();
          weights = bone.getWeights();
          for( wtIdx = 0; wtIdx < numWeights; ++wtIdx) {
            weight = weights[weightIdx];
            //weight.getVertexId();
            //weight.getWeight();
          }
          mtx = bone.getOffsetMatrix();
        }
      }

      function loadMesh(mesh) {
          // see BufferGeometry.js fromDirectGeometry()

        var geom,
            name,
            matIdx,
            numColorChannels,
            numUVChannels;

        geom = new THREE.BufferGeometry();
        name = mesh.getName();
        matIdx = mesh.getMaterialIndex();

        geom.addAttribute( 'name', name );
        geom.addAttribute( 'material_index', matIdx );

        if (!mesh.hasPositions() || !mesh.hasFaces()) {
          return geom;
        }

        loadPositions(mesh, geom);
        loadIndices(mesh, geom);
    
        if(mesh.hasNormals()) {
          loadNormals(mesh, geom);
        }

        if(mesh.hasTangentsAndBitangents()) {
          //tangents = mesh.getTangents();
          //bitangents = mesh.getBitangents();
        }

        if(mesh.hasVertexColors( 0 )) {
          loadVertexColors(mesh, geom, 0);
        }

        if(mesh.hasTextureCoords( 0 )) {
          //numUVChannels = mesh.GetNumUVChannels();
          loadTextureCoords( mesh, geom, 0 );
        }

        if(mesh.hasTextureCoords( 1 )) {
          loadTextureCoords( mesh, geom, 1 );
        }

        if(mesh.hasBones()) {
          loadBones(mesh, geom);
        }
      }

      function displayContents(contents) {
          var i = 0;

          var importer = new Module.Importer();
          var exporter = new Module.Exporter();
          var scene = importer.readFileFromMemory(contents, Module.GetTargetRealtimeMaxQualityFlags());
          
          var numMeshes = scene.getNumMeshes();
          var numMaterials = scene.getNumMaterials();
          var numLights = scene.getNumLights();
          var numAnimations = scene.getNumAnimations();
          var numTextures = scene.getNumTextures();
          var numCameras = scene.getNumCameras();

          
          for (i = 0; i < numMeshes; ++i) {
            var mesh = scene.getMesh(i);
            loadMesh(mesh);
            //scene.add(mesh);
            // how to do sub meshes???
          }

          for (i = 0; i < numMaterials; ++i) {
            var mat = scene.getMaterial(i);
          }
          for (i = 0; i < numTextures; ++i) {
            var texture = scene.getTexture(i);
          }
          //var format = "collada"; //! @see Exporter.cpp line 98 for supported formats.
          //var outStr = exporter.exportToString(scene, format, null);
          //var h = 0;
      }

  	</script>
</html>  	